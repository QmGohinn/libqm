# cplusplus

## 1 类

### 1.1 深拷贝和浅拷贝

对应拷贝构造函数和赋值构造函数。浅拷贝在类包含指针成员时会导致释放俩次内存。（因为赋值拷贝也就是浅拷贝并没有申请新的空间，而是俩个指针指向同一块地方。）。深拷贝会申请一块新的内存给拷贝出来的实体，所以如果类中含有指针成员，那么在类内要实现深拷贝构造函数。

#### 1.1.1 示例

```cpp
People::People(const People& x)
{
	this->m_Name = x.m_Name;
	this->m_Age = x.m_Age;
	this->m_ID = x.m_ID;
	this->m_Local = x.m_Local;
	this->m_Phone = x.m_Phone;
	this->m_Sex = x.m_Sex;
} // 浅拷贝也就是赋值拷贝

People::People(const People& x)
{
	this->m_Name = x.m_Name;
	this->m_Age = x.m_Age;
	this->m_ID = x.m_ID;
	this->m_Local = x.m_Local;
	this->m_Phone = x.m_Phone;
	this->m_Sex = x.m_Sex;
    
    // 指针成员的赋值 申请新的空间并且俩块空间内的值相同
    
}
```

### 1.2 内联函数

1. 同宏定义，不过

## 2 Boost

### 2.0 Boost库基础

#### 2.0.1 Boost智能指针

缺乏Java的垃圾自动回收机制，所以boost采用智能指针的方式防止出现

1. 内存泄露
2. 野指针
3. 越界访问

##### 2.0.1.1 share_ptr

1. 当成员指针变量为share_ptr时，无需自行实现拷贝构造函数。
2. 循环引用（相互引用）必然会引起内存泄露。所以引入了weak_ptr。

### 2.1 asio库

## 3 STL

## 4 OSG

## 5 QT

### 5.1 QxOrm框架

*数据库框架，对象关系映射。

## 6 基础知识点

### 6.1 内存泄露

通常指的是申请了一块内存却没有释放。

### 6.2 内存溢出

分为上溢和下溢，栈满想入栈称为上溢，栈空想出栈称为下溢。

### 6.3 线程安全

通常出现在多线程编程中的全局变量和静态变量上，如果每次取值操作都能保证取得正确的结果。并不会出现数据污染等情况，那么这个操作是线程安全的。

若一个变量不提供写操作，那么一般来说，这个操作是线程安全的。

boost里的shared_ptr是线程安全的。

### 6.4 富文本

包含图片、链接等的文本格式，普通的文本只包含文字和简单的标点符号。

### 6.5 端口号说明

80、8080：http server

443：https

ip + port = application

### 6.6 extern "C" 和 extern “C++”

分别对应C语言和C++的链接规范，因为C++语言支持函数重载，以及不同命名空间中的相同的函数名。所以经过C++编译器编译后的C语言函数实现在目标文件中标识与单纯C语言编译器编译后的目标文件是不一样的。

extern “C”中不要包含引入头文件。

名字粉碎：C++编译器会把进入编译阶段的每个源文件中暴露给外部的函数、变量等通过C++规范编译保存到中间文件中。以便链接器在链接阶段不会陷入困惑。

### 6.7 缓冲区（cin、cout、cerr）

cin 和 scanf 以及Cout 和 printf 和缓冲区其实都是标准缓冲区，是一样的。会有同步。

```c
#include <iostream>
#include <cstdio>
using namespace std;

int main()
{
    //std::ios_base::sync_with_stdio(false); 取消同步语句
    for(int i = 0; i < 10; ++i)
    {
        cout << 1 << endl;
        printf("1");
    }
    return 0;
}
```

```c++
for(int i = 0; i < 10; ++i)
{
    cout << 1 << endl;
    printf("1");
}
while(1);	
//在linux系统下什么都不会输出，而在windows系统下可以正常输入while死循环之前的内容。这说明windows下没有输出缓冲区。
//不过在windows系统下可以通过使用setbuf 和 setvbuf （同时可以设置缓冲区格式）设置缓冲区大小。
```

### 6.8.  about cmake

目的：为了实现工程的跨平台。

qt、eclipse都是跨平台的ide，所以无需我们多虑。但是在不跨平台的环境下搭建的工程就需要我们使用makefile来编译项目。

make命令单一的操纵makefile文件。qmake是qt内嵌的管理工具，无需开发者多虑。CMakeLists.txt。

### 6.9 前置声明

主要是对于类来说。类存在前置声明。类似于函数的声明和定义。

```cpp
// 函数的声明和定义分开来写，这也有助于实现C++语言模块化。
void out();

int main()
{
    out();
    return 0;
}

void out()
{
    printf("1");
}

// 同样的对于类来说，仍然存在前置声明，也就是定义和声明分开来写。
// 但定义之前声明之后 只能识别到该关键字是一个类，但并不知道这类里存在什么变量和方法。

// 此时该类为不完全类型，此时我们只能做一部分工作
// 1.定义该不完全类型的指针和引用
// 2.声明（不可以定义）以该不完全类型为参数或者返回值的函数

// 好处：
	// 1.减少编译时间
	// 2.处理类之间的依赖关系

// 坏处
	// (1) 前置声明隐藏了依赖关系，头文件改动时，用户的代码会跳过必要的重新编译过程。
	// (2) 前置声明可能会被库的后续更改所破坏。前置声明函数或模板有时会妨碍头文件开发者变动其 API.例如扩大形参类型，加个自带默认参数的模板形参等等。
	// (3) 前置声明来自命名空间std:: 的 symbol 时，其行为未定义。
	// (4) 很难判断什么时候该用前置声明，什么时候该用 #include 。极端情况下，用前置声明代替 includes 甚至都会暗暗地改变代码的含义.

class People;

```























































































# Java 

## SpringMVC、Spring、maven













































































































































# Python 













































































































































# C# 







































































































































# Go 



















































































# 网络知识



## 1 分而治之

### 1.1 mac 层（网络接口层）

报文头中添加唯一标识的物理地址（mac地址）。

### 1.2  网络层（IP层）

添加该包从哪里来，到哪里去。（源ip、目的ip）

### 1.3 传输层（TCP、UDP层）

添加端口信息，也就是要发往目的主机的哪个端口（对应 应用程序 对应进程）

### 1.4 应用层（App层）

应用层报文（用户数据）

### 1.5 基础知识

在网络世界中传输的报文理应是    mac头 + ip头 + tcp头 + 用户数据 +  ....

#### 1.5.1 MTU

网络接口层提供给IP层的最大传输宽度（一般是1500字节）。

#### 1.5.2 MSS

传输层用来要求应用层最大的数据字段大小，当然不包括TCP头部和可选字段。一般是1460（1500 - 20 - 20）。

## 2 TCP

可靠、面向连接、基于字节流。

![TCP Head](images/1460000039691686)

### 2.1 粘包

#### 2.1.1 基于字节流

字节流： 0 1 二进制数据流，0 1 数据之间不存在任何边界，所以可能被切割成任何形式，所以到接收端可能被组装成任何数据。

所以基于字节流的传输特点是造成TCP粘包的主要原因。

#### 2.1.2  解决方法

加入特定的消息开始符标识消息以及长度字段（长度字段一般是配合开始标识符一起使用）的开始，为了解决发送消息中==可能包含此标识==的情况，还要追加校验位。（CRC等等）

### 2.2 组包

为了提升效率，会开启Nagle算法。

以下俩种情况，会立即发送不等到组包。

1. 等待时间超过200ms（一般是200ms）。
2. 包长度超过MSS，会立即发送。如果没有超过MSS会等待下一个包到来，如果下一个 和 这一个包加起来超过了MSS，那么会拆分发送包。

## 3 UDP

无连接、不可靠、面向消息报

![](images/1460000039691681)

我们可以通过ip报文总长度 - ip头长度 - udp头长度 得到udp数据长度。

那么我们为什么要把冗余的udp长度字段加到udp报文头中呢？

给出的官方解释是，udp报文数据传输不一定使用IP协议，但其中最重要的原因是udp报文到达应用层，已经不包含IP报文头了，所以此时也存在隐藏的粘包风险。 所以需要添加长度字段。

UDP不存在粘包风险

## 4. IP

如果消息过长，`IP层`会按 **MTU 长度**把消息分成 **N 个切片**，每个切片带有自身在**包里的位置（offset）**和**同样的IP头信息**。

IP不关心具体数据是啥，所以也不存在粘包问题。





